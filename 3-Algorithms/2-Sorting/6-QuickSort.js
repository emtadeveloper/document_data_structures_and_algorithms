/*
=====================================================================================================================================================================
=====================================================================================================================================================================

Quick Sort  : برای مرتب کردن داده‌ها استفاده می‌کند. این الگوریتم در مقایسه با الگوریتم‌هایی مانند  Divide and Conquer یک الگوریتم مرتب‌سازی بسیار سریع و کارا است که از روش تقسیم و غلبه 

بسیار سریع‌تر عمل می‌کند، مخصوصاً برای آرایه‌های بزرگ. Bubble Sort و Insertion Sort 

مراحل اجرای Quick Sort

به‌طور کلی سه مرحله اصلی دارد Quick Sort الگوریتم

1 - انتخاب محور Pivot Selection

انتخاب می‌شود. این عنصر نقش مهمی در تقسیم‌بندی آرایه ایفا می‌کند. معمولاً می‌توان یک عنصر از ابتدای pivot یک عنصر از آرایه به‌عنوان محور یا 

می‌تواند تأثیر زیادی بر عملکرد الگوریتم داشته باشد pivot انتخاب کرد. انتخاب صحیح pivot آرایه، انتهای آرایه، یا حتی وسط آن را به‌عنوان

2 -  تقسیم  Partitioning

پس از انتخاب محور آرایه به دو بخش تقسیم می‌شود

کوچک‌تر هستند pivot بخش اول شامل تمام عناصری است که از 

در موقعیت درست خود در آرایه قرار می‌گیرد و آرایه به دو بخش تقسیم می‌شود pivot بزرگ‌تر یا برابر هستند. در این مرحله pivot بخش دوم شامل تمام عناصری است که از 

3 -بازگشتی Recursion  

هر یک از بخش‌های چپ و راست به‌صورت بازگشتی مرتب می‌شوند. این روند ادامه می‌یابد تا زمانی که هر بخش به یک آرایه تک‌عنصری تبدیل شود که به‌طور پیش‌فرض مرتب است.

پیچیدگی زمانی Quick Sort ================================================================================================================================================

حالت بهترین و متوسط : 

است. این حالت معمولاً در عمل رخ می‌دهد و الگوریتم  O(n log n) برابر  Quick Sort به‌طور تقریبی آرایه را به دو نیمه تقسیم کند پیچیدگی زمانی pivot  در حالت میانه زمانی که

در این حالت عملکرد بسیار سریعی دارد

حالت بدترین : اگر در هر تقسیم فقط یک عنصر به یکی از بخش‌ها اضافه شود (که به‌طور معمول زمانی است که آرایه از قبل مرتب یا معکوس مرتب شده باشد و انتخاب

افزایش می‌یابد. این حالت معمولاً در آرایه‌های خاص رخ می‌دهد. O(n²) بد باشد پیچیدگی زمانی به pivot 

برای مدیریت بازگشت‌های بازگشتی استفاده می‌کند stack recursion است، زیرا این الگوریتم از O(log n) به‌طور معمول  Quick Sort  پیچیدگی فضایی

=====================================================================================================================================================================

Quick Sort پیاده‌سازی الگوریتم  =============================================================================================================================================
 
*/

function quickSort(arr) {
  // اگر آرایه فقط یک یا هیچ عنصر نداشته باشد، مرتب است

  if (arr.length <= 1) {
    return arr;
  }

  // انتخاب pivot: آخرین عنصر

  const pivot = arr[arr.length - 1];
  let left = [];
  let right = [];

  // تقسیم آرایه به دو بخش: یکی با عناصری کوچکتر از pivot و دیگری با بزرگتر از pivot

  for (let i = 0; i < arr.length - 1; i++) {
    if (arr[i] < pivot) {
      left.push(arr[i]);
    } else {
      right.push(arr[i]);
    }
  }

  // بازگشتی: مرتب‌سازی بخش‌های چپ و راست و ادغام آن‌ها با pivot

  return [...quickSort(left), pivot, ...quickSort(right)];
}

// مثال
const numbers = [38, 27, 43, 3, 9, 82, 10];
console.log(quickSort(numbers));

// خروجی: [3, 9, 10, 27, 38, 43, 82]

/*

توضیح گام به گام با مثال

فرض کنید آرایه‌ای داریم : [38, 27, 43, 3, 9, 82, 10]

pivot گام 1 ) انتخاب 

انتخاب کرده‌ایم: pivot انتخاب می‌کنیم. در این پیاده‌سازی، آخرین عنصر آرایه را به‌عنوان pivot ابتدا یک 

pivot = 10

گام 2 ):  تقسیم آرایه 

حالا آرایه را به دو بخش تقسیم می‌کنیم :

[3, 9] کوچک‌ترند pivot بخش چپ شامل تمام عناصری است که از

[38, 27, 43, 82] بزرگ‌تر یا برابرند pivot بخش راست شامل تمام عناصری است که از

Recursion گام 3: بازگشتی 

حالا روی دو بخش [3, 9] و [38, 27, 43, 82] الگوریتم را بازگشتی فراخوانی می‌کنیم برای بخش چپ [3, 9]

[] بخش چپ: [3] بخش راست

بنابراین، این بخش به‌صورت مرتب [3, 9] برمی‌گردد

برای بخش راست [38, 27, 43, 82]:

انتخاب pivot: 82

بخش چپ: [38, 27, 43]

بخش راست: []

حالا روی [38, 27, 43] الگوریتم را بازگشتی فراخوانی می‌کنیم

انتخاب pivot: 43

بخش چپ: [27]

بخش راست: [38]

بنابراین این بخش به‌صورت مرتب [27, 38, 43] برمی‌گردد

گام 4: ادغام نهایی

حالا تمام بخش‌ها با هم ادغام می‌شوند:

[3, 9], [10], [27, 38, 43], [82] → [3, 9, 10, 27, 38, 43, 82]

=====================================================================================================================================================================
=====================================================================================================================================================================
*/
