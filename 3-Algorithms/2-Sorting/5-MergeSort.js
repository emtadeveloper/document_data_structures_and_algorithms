/*
=====================================================================================================================================================================
=====================================================================================================================================================================

Merge Sort : عمل می‌کند این الگوریتم ابتدا آرایه Divide and Conquer یکی از الگوریتم‌های مرتب‌سازی قدرتمند است که بر پایه تکنیک تقسیم و غلبه

را به زیرآرایه‌های کوچک‌تر تقسیم می‌کند، سپس این زیرآرایه‌ها را مرتب کرده و در نهایت آن‌ها را با هم ادغام می‌کند تا یک آرایه مرتب تولید شود

Merge Sort مراحل اجرای  ==================================================================================================================================================

1 - تقسیم Divide : آرایه اصلی به دو نیمه تقسیم می‌شود. این کار تا زمانی ادامه پیدا می‌کند که هر زیرآرایه تنها شامل یک عنصر باشد (چون یک عنصر به‌خودی‌خود مرتب است)

2 - غلبه Conquer: زیرآرایه‌ها به‌صورت بازگشتی مرتب می‌شوند

3 - ادغام Merge: دو زیرآرایه مرتب‌شده در هر سطح از بازگشت با هم ادغام می‌شوند تا یک زیرآرایه بزرگ‌تر و مرتب ایجاد شود

=====================================================================================================================================================================

پیچیدگی زمانی ==========================================================================================================================================================

حالت بهترین، بدترین، و متوسط:

سطح و مرتب‌سازی در هر سطح است logn است دلیل آن، تقسیم آرایه بهBigO( nlogn )  در همه حالات، پیچیدگی زمانی 

پیچیدگی فضایی:

است BigO(n) به دلیل استفاده از آرایه‌های موقت برای ادغام، پیچیدگی فضایی

*/
function mergeSort(arr) {
  // اگر آرایه تنها یک عنصر دارد، مرتب است
  if (arr.length <= 1) {
    return arr;
  }

  // تقسیم آرایه به دو نیمه
  const mid = Math.floor(arr.length / 2);
  const left = arr.slice(0, mid);
  const right = arr.slice(mid);

  // مرتب‌سازی بازگشتی دو نیمه و ادغام آن‌ها
  return merge(mergeSort(left), mergeSort(right));
}

function merge(left, right) {
  let result = [];
  let i = 0,
    j = 0;

  // مقایسه و ترکیب عناصر دو آرایه
  while (i < left.length && j < right.length) {
    if (left[i] < right[j]) {
      result.push(left[i]);
      i++;
    } else {
      result.push(right[j]);
      j++;
    }
  }

  // اضافه کردن عناصر باقی‌مانده
  return result.concat(left.slice(i)).concat(right.slice(j));
}

// مثال

const numbers = [38, 27, 43, 3, 9, 82, 10];
console.log(mergeSort(numbers));

// خروجی: [3, 9, 10, 27, 38, 43, 82]

// توضیح گام به گام با مثال

// فرض کنیم آرایه ما باشد:
// [38, 27, 43, 3, 9, 82, 10]

// گام 1: تقسیم
// تقسیم آرایه به دو نیمه:
// [38, 27, 43] و [3, 9, 82, 10]

// ادامه تقسیم:

// [38, 27, 43] → [38] و [27, 43] → [27] و [43]
// [3, 9, 82, 10] → [3, 9] و [82, 10] → [3], [9], [82], [10]

// گام 2: مرتب‌سازی و ادغام
// مرتب‌سازی و ادغام زیرآرایه‌های تک‌عنصری:

// [27] و [43] → [27, 43]
// [3] و [9] → [3, 9]
// [82] و [10] → [10, 82]
// ادغام مراحل بالاتر:

// [38] و [27, 43] → [27, 38, 43]
// [3, 9] و [10, 82] → [3, 9, 10, 82]
// ادغام نهایی:

// [27, 38, 43] و [3, 9, 10, 82] → [3, 9, 10, 27, 38, 43, 82]


// =====================================================================================================================================================================
// =====================================================================================================================================================================