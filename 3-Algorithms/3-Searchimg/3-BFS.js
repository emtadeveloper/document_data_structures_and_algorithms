/*
=====================================================================================================================================================================
=====================================================================================================================================================================

یا جستجوی اول عرضی یکی از الگوریتم‌های پایه‌ای برای جستجو در گراف‌ها است. در این الگوریتم، گراف به‌صورت سطح به سطح جستجو می‌شود. یعنی BFS الگوریتم 

BFS ابتدا از گره‌ای شروع می‌کنیم، سپس تمامی گره‌های متصل به آن را بررسی می‌کنیم، و به همین ترتیب ادامه می‌دهیم تا تمام گراف مورد جستجو قرار گیرد الگوریتم

و پیدا کردن unweighted graph به‌طور معمول برای مسائل گرافی استفاده می‌شود و می‌تواند در مسائل مانند پیدا کردن کوتاه‌ترین مسیر در گراف‌های بدون وزن    

همبستگی‌ های گراف‌ها مفید باشد

=====================================================================================================================================================================

BFS مفهوم ============================================================================================================================================================

ابتدا گره شروع را در نظر می‌گیرد و سپس تمامی گره‌های مجاور آن را بررسی می‌کند BFS

ذخیره می‌شوند. این بدان معناست که گره‌ها به ترتیب وارد صف می‌شوند و به ترتیب هم بررسی می‌شوند queue گره‌ها در یک صف

این فرآیند تا زمانی که تمام گره‌ها بررسی شوند ادامه می‌یابد

=====================================================================================================================================================================

پیچیدگی زمانی (Time Complexity)

تعداد یال‌ها است. E  تعداد گره‌ها و  V  است که در آن O(V + E)  تمامی گره‌ها و یال‌ها را بررسی می‌کند. بنابراین، پیچیدگی زمانی این الگوریتم  BFS در بدترین حالت

پیچیدگی فضایی (Space Complexity)

است O(V)  برابر با  visited پیچیدگی فضایی این الگوریتم به دلیل استفاده از صف و مجموعه

=====================================================================================================================================================================
 
در جاوااسکریپت  BFS پیاده‌سازی  ============================================================================================================================================
 
در جاوااسکریپت آورده شده است queue با استفاده از ساختار داده‌ای صف BFS در اینجا پیاده‌سازی الگوریتم 

*/

function bfs(graph, start) {
  let visited = new Set(); // مجموعه‌ای برای ذخیره گره‌های بازدید شده
  let queue = []; // صف برای ذخیره گره‌های در حال بررسی

  // شروع از گره اولیه
  visited.add(start);
  queue.push(start);

  while (queue.length > 0) {
    let node = queue.shift(); // برداشتن گره از ابتدای صف
    console.log(node); // گره جاری را چاپ می‌کنیم

    // بررسی گره‌های مجاور
    for (let neighbor of graph[node]) {
      if (!visited.has(neighbor)) {
        visited.add(neighbor); // افزودن گره به مجموعه بازدید شده
        queue.push(neighbor); // افزودن گره به صف برای بررسی‌های بعدی
      }
    }
  }
}

// تعریف گراف به‌صورت لیست همسایگی (adjacency list)

const largeGraph = {
  A: ["B", "C", "D"],
  B: ["A", "E", "F"],
  C: ["A", "G", "H"],
  D: ["A"],
  E: ["B"],
  F: ["B"],
  G: ["C"],
  H: ["C"],
};

// تست الگوریتم BFS

bfs(largeGraph, "A");

/*

bfs(graph, start) تابع

graph: که در آن هر گره به یک لیست از گره‌های مجاور خود متصل است adjacency list گراف به‌صورت لیست همسایگی

start: گره‌ای که از آن شروع به جستجو می‌کنیم

در داخل تابع

برای ذخیره گره‌های بازدید شده ایجاد می‌کنیم visited یک مجموعه 

برای ذخیره گره‌هایی که باید بررسی شوند، ایجاد می‌کنیم queue یک صف 

اضافه می‌کنیم visited  ابتدا گره شروع را به صف اضافه کرده و آن را به مجموعه

شروع می‌شود که تا زمانی که صف خالی نباشد، گره‌ها را یکی‌یکی از صف برداشته و بررسی می‌کند while سپس یک حلقه 

اضافه می‌شوند. visited گره‌های مجاور گره جاری بررسی می‌شوند و اگر هنوز بازدید نشده باشند، به صف و مجموعه

=====================================================================================================================================================================
=====================================================================================================================================================================
*/
