/*
=====================================================================================================================================================================
=====================================================================================================================================================================
 
Binary Search  ( جستجوی دودویی)  : یکی از الگوریتم‌های بسیار کارآمد برای جستجو در آرایه‌های مرتب شده است. این الگوریتم به‌صورت بازگشتی یا تکراری عمل می‌کند و جستجو    

است Linear Search است که به‌طور قابل توجهی سریع‌تر از O(log n) را با تقسیم  آرایه به دو نیمه انجام می‌دهد که باعث کاهش تعداد مقایسه‌ها می‌شود. پیچیدگی زمانی آن

این الگوریتم فقط در آرایه‌های مرتب شده کاربرد دارد. اگر آرایه مرتب نباشد، ابتدا باید آن را مرتب کنید و سپس از این الگوریتم استفاده کنید 

این الگوریتم برای آرایه‌های بزرگ بسیار کارآمد است و زمان جستجو را به‌طور قابل توجهی کاهش می‌دهد

=====================================================================================================================================================================

با استفاده از جاوااسکریپت Binary Search در اینجا نحوه پیاده‌سازی الگوریتم  =============================================================================================================

1  ) ابتدا وسط آرایه یا لیست را پیدا می‌کنیم

2  ) اگر مقدار وسط برابر با مقدار مورد نظر باشد، جستجو تمام می‌شود

3  ) اگر مقدار وسط بزرگ‌تر از مقدار هدف باشد، جستجو در نیمه چپ آرایه ادامه می‌یابد

4  ) اگر مقدار وسط کوچک‌تر از مقدار هدف باشد، جستجو در نیمه راست آرایه ادامه می‌یابد

5 ) این روند تا زمانی که مقدار مورد نظر پیدا شود یا آرایه تمام شود ادامه می‌یابد

*/

function binarySearch(arr, target) {
  let low = 0; // ایندکس ابتدایی آرایه
  let high = arr.length - 1; // ایندکس پایانی آرایه

  while (low <= high) {
    const mid = Math.floor((low + high) / 2); // پیدا کردن ایندکس وسط

    // اگر عنصر وسط برابر با هدف باشد
    if (arr[mid] === target) {
      return mid; // ایندکس عنصر پیدا شده
    }

    // اگر هدف کوچک‌تر از عنصر وسط باشد
    if (arr[mid] > target) {
      high = mid - 1; // جستجو در نیمه چپ
    } else {
      low = mid + 1; // جستجو در نیمه راست
    }
  }

  return -1; // اگر عنصر در آرایه پیدا نشد
}

// تست الگوریتم
const numbers = [10, 20, 30, 40, 50];
const targetValue = 30;

const result = binarySearch(numbers, targetValue);
if (result !== -1) {
  console.log(`Element found at index ${result}`);
} else {
  console.log("Element not found");
}

/*=====================================================================================================================================================================

binarySearch(arr, target) تابع

arr: آرایه‌ای که می‌خواهیم در آن جستجو کنیم توجه کنید که آرایه باید مرتب باشد

target: عنصر مورد نظر که به دنبال آن هستیم

در داخل تابع:

هر بار وسط آرایه (یا بخش مربوطه) پیدا می‌شود while ایندکس پایانی آرایه را مشخص می‌کند با استفاده از یک حلقه  high  ایندکس ابتدایی آرایه و  low متغیر 

و با مقدار هدف مقایسه می‌شود

اگر مقدار هدف پیدا شد، ایندکس آن برگردانده می‌شود

اگر مقدار هدف کوچک‌تر از مقدار وسط باشد، جستجو در بخش چپ ادامه می‌یابد

اگر مقدار هدف بزرگ‌تر از مقدار وسط باشد، جستجو در بخش راست ادامه می‌یابد

پیچیدگی زمانی (Time Complexity) : است. چون هر بار آرایه به نصف تقسیم می‌شود و در هر مرحله، فقط یک مقایسه انجام می‌شود O(log n)  پیچیدگی زمانی این الگوریتم

پیچیدگی فضایی (Space Complexity) :  است O(1) این الگوریتم از فضای اضافی استفاده نمی‌کند (غیر از متغیرهای داخلی)، بنابراین پیچیدگی فضایی آن

*/ //=====================================================================================================================================================================
//=======================================================================================================================================================================
