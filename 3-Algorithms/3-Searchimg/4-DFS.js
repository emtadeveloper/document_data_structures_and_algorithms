/*
=====================================================================================================================================================================
=====================================================================================================================================================================

جستجوی عمقی یکی از الگوریتم‌های پایه‌ای برای پیمایش یا جستجوی گراف‌ها یا درخت‌ها است. در این الگوریتم، از ریشه شروع کرده و تا زمانی که شاخه‌های DFS الگوریتم

یا به‌صورت بازگشتی پیاده‌سازی می‌شود در اینجا نحوه پیاده‌سازی Stack جدیدی وجود دارد، به عمق بیشتری از گراف یا درخت می‌رود. این الگوریتم به‌طور معمول با استفاده از پشته

در جاوااسکریپت آورده شده است DFS 

======================================================================================================================================================================

مفهوم DFS =============================================================================================================================================================

شروع از یک گره خاص در گراف یا درخت، به عمق می‌رود تا زمانی که به گره برگشتی (مانند برگ‌ها یا گره‌هایی که همسایه‌ای ندارند) برسد DFS در الگوریتم 

سپس، الگوریتم به عقب برمی‌گردد و گره‌های همسایه دیگر را بررسی می‌کند این الگوریتم معمولاً از پشته برای ذخیره گره‌های که باید بررسی شوند استفاده 

می‌کند در پیاده‌سازی بازگشتی، هر فراخوانی تابع به‌طور خودکار مانند یک پشته عمل می‌کند

======================================================================================================================================================================

پیچیدگی زمانی و فضایی  ===================================================================================================================================================

است که در آن O(V + E) تمام گره‌ها و یال‌های گراف را بررسی می‌کند. بنابراین، پیچیدگی زمانی آن DFS  پیچیدگی زمانی: در بدترین حالت، الگوریتم

V تعداد گره‌ها (Vertices)

E تعداد یال‌ها (Edges)

پیچیدگی فضایی: پیچیدگی فضایی بستگی به تعداد گره‌های بازدید شده دارد. در بدترین حالت، فضای ذخیره‌سازی به اندازه

است O(V) تعداد گره‌ها نیاز خواهد داشت، بنابراین پیچیدگی فضایی آن

=====================================================================================================================================================================

با استفاده از پشته در جاوااسکریپت DFS پیاده‌سازی  ===============================================================================================================================

*/
function dfs(graph, start) {
  const stack = [start]; // ایجاد پشته با گره شروع
  const visited = new Set(); // مجموعه‌ای برای ذخیره گره‌های بازدید شده

  while (stack.length > 0) {
    const node = stack.pop(); // خارج کردن آخرین عنصر از پشته
    if (!visited.has(node)) {
      console.log(node); // انجام عملیاتی مانند چاپ گره
      visited.add(node); // علامت‌گذاری گره به‌عنوان بازدید شده
    }

    // اضافه کردن گره‌های همسایه به پشته
    graph[node].forEach((neighbor) => {
      if (!visited.has(neighbor)) {
        stack.push(neighbor); // گره‌های همسایه را به پشته اضافه می‌کنیم
      }
    });
  }
}

// گراف به‌صورت شیء (Adjacency List)

const graph = {
  A: ["B", "C"],
  B: ["A", "D", "E"],
  C: ["A", "F"],
  D: ["B"],
  E: ["B", "F"],
  F: ["C", "E"],
};

// تست الگوریتم DFS

dfs(graph, "A");

/* 

dfs(graph, start) تابع

graph:  ذخیره شده است. هر گره به یک آرایه از همسایگانش اشاره دارد adjacency list گراف ورودی که به‌صورت لیست مجاورت

start: گره‌ای که از آن شروع می‌کنیم

مجموعه visited: این مجموعه برای ذخیره گره‌های بازدید شده است تا از بازدید دوباره آن‌ها جلوگیری کنیم

پشته stack: پشته‌ای برای ذخیره گره‌های بعدی که باید بررسی شوند. ابتدا گره شروع به پشته اضافه می‌شود

حلقه while (stack.length > 0): این حلقه تا زمانی که پشته خالی نشده باشد اجرا می‌شود. در هر مرحله

آخرین گره از پشته خارج می‌شود

اضافه می‌کنیم. visited   اگر این گره قبلاً بازدید نشده باشد، آن را چاپ کرده و به مجموعه  

سپس همسایگان گره را به پشته اضافه می‌کنیم، در صورتی که آن‌ها قبلاً بازدید نشده باشند



=====================================================================================================================================================================
=====================================================================================================================================================================
*/
