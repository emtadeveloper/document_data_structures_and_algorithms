/*
=============================================================================================================================================================
=============================================================================================================================================================

Big O قوانین ساده‌سازی 

تحت چه شرایطی بهینه‌سازی کد باعث تغییر مرتبه پیچیدگی می‌شود؟

1 ) جایگزینی الگوریتم ناکارآمد با الگوریتم بهینه‌تر

جستجوی خطی O(n) -->  جستجوی دودویی O(logn)

2 ) انتخاب ساختار داده مناسب

O(n) به جای آرایه معمولی  O(1) استفاده از هش‌مپ

3 ) حذف محاسبات تکراری

در برنامه‌های بازگشتی Memoization استفاده از ذخیره‌سازی نتایج محاسبات

4 ) تقسیم و حل

O(nlog n) Merge Sort استفاده از الگوریتم‌های تقسیم و حل مانند 

*/
// =============================================================================================================================================================

// ( Worst Case ) قانون اول: بدترین حالت

// همواره بدترین حالت ممکن اجرای کد را بررسی می‌کنیم. این تضمین می‌کند که حتی در بدترین شرایط نیز Big O در تحلیل

// الگوریتم عملکرد پیش‌بینی‌پذیری دارد

function linearSearch(arr, target) {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === target) {
      return i; // پیدا شد
    }
  }
  return -1; // پیدا نشد
}

// O(1) بهترین حالت : مقدار در اولین خانه باشد

// O(n) بدترین حالت: مقدار وجود نداشته باشد یا در آخرین خانه باشد

// چرا این قانون ؟

// بدترین حالت به ما اطمینان می‌دهد که حتی در بدترین شرایط برنامه زمان‌بندی مشخصی خواهد داشت

// =============================================================================================================================================================

// (Remove Constants) قانون دوم: حذف ضرایب

//بسیار کوچک می‌شود n ضرایب ثابت کنار گذاشته می‌شوند زیرا تأثیر آن‌ها با بزرگ شدن ورودی Big O در تحلیل

function doubleLoop(arr) {
  for (let i = 0; i < arr.length; i++) {
    console.log(arr[i]);
  }
  for (let i = 0; i < arr.length; i++) {
    console.log(arr[i]);
  }
}

// تعداد عملیات : O(2n)

// حذف ضرایب : O(2n)→O(n)

// =============================================================================================================================================================

// (Different Terms for Inputs) قانون سوم : ورودی‌های مستقل

// وقتی الگوریتم با چند ورودی مستقل کار می‌کند هر ورودی جداگانه تحلیل می‌شود و نمی‌توان آن‌ها را با هم ترکیب کرد

// اگر ورودی‌ها مستقل باشند نمی‌توان تأثیرشان را یکجا محاسبه کرد

function processArrays(arr1, arr2) {
  for (let i = 0; i < arr1.length; i++) {
    console.log(arr1[i]);
  }
  for (let j = 0; j < arr2.length; j++) {
    console.log(arr2[j]);
  }
}
// پیچیدگی حلقه اول : O(n) برای  arr1
//  پیچدگی حلقه دوم : O(m) برای  arr2
// پیچیدگی نهایی  :  O(n) + O(m)

// =============================================================================================================================================================

// (Drop Non-Dominants) قانون چهارم: حذف غیر غالب‌ ها

// ندین عبارت وجود دارد، فقط عبارتی که بیشترین رشد را دارد نگه می‌داریم و بقیه را حذف می‌کنیم Big O در تحلیل

function complexFunction(arr) {
  for (let i = 0; i < arr.length; i++) {
    console.log(arr[i]);
  }
  for (let i = 0; i < arr.length; i++) {
    for (let j = 0; j < arr.length; j++) {
      console.log(arr[i], arr[j]);
    }
  }
}
// پیچیدگی حلقه اول : O(n) برای
//  پیچدگی حلقه دوم : O(n²) برای
// پیچیدگی نهایی  :  O(n) + O(n²) : O(n²)

// =============================================================================================================================================================
// =============================================================================================================================================================
