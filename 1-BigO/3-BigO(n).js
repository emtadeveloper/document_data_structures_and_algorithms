/*
=============================================================================================================================================================
=============================================================================================================================================================

Linear یا Big O(n)  مفهوم اصلی  : 

رابطه دارد اگر ورودی بزرگ‌تر شود ( n ) به این معنی است که زمان اجرای کد به طور مستقیم با اندازه ورودی Big O(n)

زمان اجرا نیز به همان نسبت افزایش می‌یابد این رفتار درالگوریتم‌هایی دیده می‌شود که نیاز دارند یک بار تمام عناصر

یک لیست آرایه یا مجموعه را پردازش کنند

Big O(n) ویژگی‌های اصلی  =====================================================================================================================================

1 ) افزایش خطی زمان اجرا

وقتی ورودی دو برابر می‌شود زمان اجرا نیز تقریباً دو برابر خواهد شد

2 ) پردازش یک‌بار هر عنصر

هر عنصر ورودی دقیقاً یک بار پردازش می‌شود O(n) در الگوریتم‌های 

3 ) مناسب برای آرایه‌ها و لیست‌ها

این پیچیدگی در جاوااسکریپت معمولاً در توابعی دیده می‌شود که از حلقه‌ها یا توابع تکرارشونده استفاده می‌کنند

( forEach یا map مثل) 

4- هامون هم بیشتر می شود operation های ورودی مون بیشتر بشه تعداد Element هر چه 

=============================================================================================================================================================

اگر فانکشنی داشته باشیم که مقدار ۱۰۰۰ خانه اول آرایه را چاپ کند پیچیدگی زمانی‌اش چیست ؟

function printFirstThousand(array) {
    for (let i = 0; i < 1000; i++) {
        console.log(array[i]);
    }
}

فانکشن همیشه دقیقاً ۱۰۰۰ بار اجرا می‌شود n در این کد صرف‌نظر از اندازه آرایه

هامون تغیری نمیکنه  و شیب دار نمی شود فقط ارتفاع در نمودار بیشتر می شود operation المنت هامون زیاد شود

است زیرا تعداد اجرای حلقه ثابت است O(1) تعداد تکرارها وابسته به اندازه آرایه نیست بنابراین پیچیدگی زمانی

تغییر می‌کند O(n) اگر تعداد عناصر چاپی متغیر باشد ( مثلاً تمام عناصر آرایه ) پیچیدگی زمانی به

=============================================================================================================================================================

است ؟ O(n) آیا پیچیدگی زمانی حلقه‌ها همیشه

خیر، پیچیدگی زمانی حلقه‌ها به شرایط زیر بستگی دارد

است O(n) شرایطی که پیچیدگی حلقه ===========================================================================================================================

است O(n)  اگر حلقه یک بار برای هر عنصر از ورودی اجرا شود پیچیدگی

const array = [1, 2, 3, 4, 5];
for (let i = 0; i < array.length; i++) {
    console.log(array[i]);
}

شرایطی که پیچیدگی حلقه متفاوت است ===========================================================================================================================

1 )

خواهد بود O(1) اگر حلقه تعداد ثابت و از پیش تعریف شده‌ای از تکرار داشته باشد، پیچیدگی زمانی Fixed Loop حلقه ثابت

for (let i = 0; i < 100; i++) {
    console.log(i);
}

2 )

اگر یک حلقه داخل حلقه دیگری باشد، پیچیدگی زمانی برابر با ضرب تعداد تکرارهای حلقه‌ها خواهد بود Nested Loops حلقه‌های تو در تو

const array = [1, 2, 3];
for (let i = 0; i < array.length; i++) {
    for (let j = 0; j < array.length; j++) {
        console.log(array[i], array[j]);
    }
}

3 )

تناسب با مربع تعداد عناصر آرایه O(n²)

خواهد بود O( logn ) حلقه کاهش‌ دهنده اگر حلقه به صورت نمایی یا لگاریتمی مقدار متغیر شمارنده را تغییر دهد، پیچیدگی زمانی

for (let i = 1; i < n; i *= 2) {
    console.log(i);
}

افزایش لگاریتمی  O(logn) : پیچیدگی 

==============================================================================================================================================================

*/ // Big O(n) مثال از پیچدگی ===============================================================================================================================

// مثال ۱ : جستجوی یک عنصر در آرایه

// این کد بررسی می‌کند که آیا یک عنصر خاص در آرایه وجود دارد یا خیر

function findElement(array, target) {
  for (let i = 0; i < array.length; i++) {
    if (array[i] === target) {
      return true;
    }
  }
  return false;
}

const numbers1 = [1, 2, 3, 4, 5];
console.log(findElement(numbers1, 3)); // خروجی: true
console.log(findElement(numbers1, 6)); // خروجی: false

// است O(n) زمان اجرا 𝑛 در بدترین حالت تمام عناصر آرایه بررسی می‌شوند و برای آرایه‌ای با اندازه

// ==============================================================================================================================================================

// مثال  ۲: شمارش تعداد وقوع یک عنصر

// این مثال تعداد دفعاتی که یک مقدار خاص در آرایه تکرار شده است را محاسبه می ‌کند

function countOccurrences(array, target) {
  let count = 0;
  for (let i = 0; i < array.length; i++) {
    if (array[i] === target) {
      count++;
    }
  }
  return count;
}

const numbers2 = [1, 2, 3, 2, 4, 2, 5];
console.log(countOccurrences(numbers2, 2)); // خروجی: 3

// است O(n) n حلقه تمام عناصر آرایه را بررسی می‌کند  زمان اجرا برای ورودی با اندازه

// ==============================================================================================================================================================

// مثال ۳: جمع‌آوری داده از یک آرایه

// این مثال همه مقادیر بزرگ‌تر از ۱۰ را از یک آرایه جمع‌آوری می‌کند

function filterGreaterThanTen(array) {
  let result = [];
  for (let i = 0; i < array.length; i++) {
    if (array[i] > 10) {
      result.push(array[i]);
    }
  }
  return result;
}

const numbers = [5, 15, 25, 10, 30, 7];
console.log(filterGreaterThanTen(numbers)); // خروجی: [15, 25, 30]

//است O(n) n  حلقه یک بار تمام عناصر آرایه را بررسی می‌کند زمان اجرا برای ورودی با اندازه

// ==============================================================================================================================================================

// مثال ۴: ادغام دو آرایه

// این مثال دو آرایه را در یک آرایه جدید ادغام می‌کند

function mergeArrays(array1, array2) {
  let merged = [];
  for (let i = 0; i < array1.length; i++) {
    merged.push(array1[i]);
  }
  for (let i = 0; i < array2.length; i++) {
    merged.push(array2[i]);
  }
  return merged;
}

const array1 = [1, 2, 3];
const array2 = [4, 5, 6];
console.log(mergeArrays(array1, array2)); // خروجی: [1, 2, 3, 4, 5, 6]

// در نظر گرفت O(n) مشابه باشند می‌توان پیچیدگی را n , m اگر O(m) است و حلقه دوم O(n) حلقه اول

// ==============================================================================================================================================================

// مثال ۵ : بازنویسی یک رشته

// را از یک رشته حذف می‌کند Spaces این مثال تمام فاصله‌ها

function removeSpaces(string) {
  let result = "";
  for (let i = 0; i < string.length; i++) {
    if (string[i] !== " ") {
      result += string[i];
    }
  }
  return result;
}

const input = "Big O Notation is great!";
console.log(removeSpaces(input)); // خروجی: "BigONotationisgreat!"

// است O(n) حلقه به اندازه طول رشته اجرا می‌شود پیچیدگی زمانی برابر با

// ==============================================================================================================================================================

// رو توضیح بدین Big(O) مثال 6 : تابع زیر

function funcChallenge(input) {
  let a = 10; // O(1)
  a = 50 + 3; // O(1)

  for (let i = 0; i < input.length; i++) {
    // O(n)
    anotherFunction(); // O(n)
    let stranger = true; // O(n)
    a++; // O(n)
  }
  return a; // O(1)
}

// Big O(3 + 4n) =>  O(n)

// ==============================================================================================================================================================

// رو توضیح بدین Big(O) مثال 7 : تابع زیر

function anotherFuncChallenge(input) {
  let a = 5; // O(1)
  let b = 10; // O(1)
  let c = 50; // O(1)
  for (let i = 0; i < input; i++) {
    let x = i + 1; // O(n)
    let y = i + 2; // O(n)
    let z = i + 3; // O(n)
  }
  for (let j = 0; j < input; j++) {
    let p = j * 2; // O(n)
    let q = j * 2; // O(n)
  }
  let whoAmI = "I don't know"; // O(1)
}

// Big O(4 + 5n) =>  O(n)

// ==============================================================================================================================================================
