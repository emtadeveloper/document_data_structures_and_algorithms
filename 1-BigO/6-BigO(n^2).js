/*
=============================================================================================================================================================
=============================================================================================================================================================

این معناست که زمان اجرای الگوریتم به صورت توان دوم اندازه ورودی رشد می‌کند این معمولاً در O(n^2) پیچیدگی زمانی 

باشند جایی که هر حلقه کل ورودی را پردازش می‌کند Nested Loops کدهایی رخ می‌دهد که شامل حلقه‌های تو در تو

مناسب برای داده‌های کوچک است اما با افزایش اندازه ورودی به شدت ناکارآمد می‌شود

بهینه‌سازی چنین الگوریتم‌هایی اغلب از طریق کاهش تعداد تکرارها یا استفاده از الگوریتم‌های هوشمندتر انجام می‌شود

ویژگی‌های O(n²) ==============================================================================================================================================

1 ) مقیاس‌ پذیری ضعیف : این نوع پیچیدگی در داده‌های بزرگ عملکرد بسیار کندی دارد

2 ) شکل رایج : معمولاً در الگوریتم‌های مبتنی بر حلقه‌های تو در تو دیده می‌شود

3 ) عملکرد : زمان اجرا به شدت به اندازه ورودی وابسته است؛ اگر ورودی دو برابر شود، زمان اجرا چهار برابر می‌شود

ناکارآمد است؟ O(n²) چرا  ====================================================================================================================================

1 ) در داده‌های کوچک عملکرد قابل قبولی دارد، اما با افزایش حجم داده‌ها، زمان اجرا به شدت افزایش می‌یابد

2 ) در اکثر موارد، می‌توان با تغییر الگوریتم یا استفاده از روش‌های پیشرفته‌تر، به پیچیدگی زمانی بهتری رسید

=============================================================================================================================================================
=============================================================================================================================================================
*/
// مثال 1 ) یافتن جفت‌ها در آرایه

function findPairs(arr) {
  for (let i = 0; i < arr.length; i++) {
    // حلقه اول
    for (let j = 0; j < arr.length; j++) {
      // حلقه دوم
      console.log(arr[i], arr[j]); // چاپ هر جفت
    }
  }
}
// چون برای هر عنصر حلقه داخلی تمام عناصر را پردازش می‌کند O(n²)

const array1 = [1, 2, 3];
findPairs(array1);
// خروجی:
// 1 1
// 1 2
// 1 3
// 2 1
// 2 2
// 2 3
// 3 1
// 3 2
// 3 3

// =============================================================================================================================================================

// مثال 2 ) حذف عناصر تکراری از آرایه

function removeDuplicates(arr) {
  const unique = [];
  for (let i = 0; i < arr.length; i++) {
    let isDuplicate = false;
    for (let j = 0; j < unique.length; j++) {
      if (arr[i] === unique[j]) {
        isDuplicate = true;
        break;
      }
    }
    if (!isDuplicate) {
      unique.push(arr[i]);
    }
  }
  return unique;
}

const array2 = [1, 2, 2, 3, 3, 3];
console.log(removeDuplicates(array2)); // خروجی: [1, 2, 3]

// حلقه بیرونی عناصر آرایه را پیمایش می‌کند

//  اجرا می‌شود unique حلقه داخلی برای بررسی وجود عنصر در آرایه

// پیچیدگی زمانی : O(n²)

// =============================================================================================================================================================

// Bubble Sort مثال 3 ) مرتب‌سازی با الگوریتم

function bubbleSort(arr) {
  for (let i = 0; i < arr.length; i++) {
    for (let j = 0; j < arr.length - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        // جا‌به‌جا کردن
        const temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
  }
  return arr;
}

const array = [5, 3, 8, 4, 2];
console.log(bubbleSort(array)); // خروجی: [2, 3, 4, 5, 8]

//  بار اجرا می‌شود n حلقه بیرونی

// بار اجرا می‌شود n−i−1 حلقه داخلی در هر بار اجرای حلقه بیرونی

// O(n²) پیچیدگی زمانی

// =============================================================================================================================================================
// را کاهش دهیم؟ O(n²) چطور
// =============================================================================================================================================================

// 1. کاهش تعداد تکرارها

// اگر برخی عملیات در حلقه داخلی تکراری یا غیرضروری باشد، آن‌ها را حذف کنیم

function optimizedBubbleSort(arr) {
  let swapped;
  for (let i = 0; i < arr.length; i++) {
    swapped = false;
    for (let j = 0; j < arr.length - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        const temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
        swapped = true;
      }
    }
    if (!swapped) break; // اگر دیگر نیازی به جابه‌جایی نباشد، حلقه متوقف می‌شود
  }
  return arr;
}

// الگوریتم در آرایه‌های تقریباً مرتب سریع‌تر اجرا می‌شود Early Exit با استفاده از

// است اما در عمل سریع‌تر است O(n²) این کار هنوز

// =============================================================================================================================================================

// 2. استفاده از الگوریتم‌های بهتر
// در بسیاری از موارد، الگوریتم‌های پیشرفته‌تر می‌توانند پیچیدگی زمانی را کاهش دهند
// BigO(nlogn) پیچیدگی Merge Sort بهبود مرتب‌سازی با

function mergeSort(arr) {
  if (arr.length <= 1) return arr;

  const mid = Math.floor(arr.length / 2);
  const left = mergeSort(arr.slice(0, mid));
  const right = mergeSort(arr.slice(mid));

  return merge(left, right);
}

function merge(left, right) {
  const result = [];
  let i = 0,
    j = 0;

  while (i < left.length && j < right.length) {
    if (left[i] < right[j]) {
      result.push(left[i]);
      i++;
    } else {
      result.push(right[j]);
      j++;
    }
  }

  return result.concat(left.slice(i)).concat(right.slice(j));
}

const array3 = [5, 3, 8, 4, 2];
console.log(mergeSort(array3)); // خروجی: [2, 3, 4, 5, 8]

// دارد و بسیار کارآمدتر است BigO(nlogn) این الگوریتم پیچیدگی زمانی

// =============================================================================================================================================================
// =============================================================================================================================================================
